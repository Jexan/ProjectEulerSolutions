from collections import defaultdict, Counter
from itertools import combinations, islice, takewhile, chain
from math import factorial, gcd, floor

sieve_generators = {}

def generate_fibonacci():
    """ Generate infinite fibonacci numbers.

        Yields:
            A number that is generated by the fibonacci sequence.

        Used by:
            002
    """
    prev, current = 0, 1

    while True:
        yield current

        prev, current = current, prev + current

def primes_until(n):
    """ Generate the primes numbers lesser or equal to n.
    
        Args:
            n: An int.
    
        Yields:
            A prime number leq to n.

        Used by:
            003, 010, 027, 041, 069, 087
    """
    sieve = [0] * n  
    
    yield 2
    for i in range(3, n, 2):
        if sieve[i]:
            continue

        yield i

        for j in range(i**2, n, i):
            sieve[j] = True 

def is_palindrome(n):
    """ Check whether the passed number is a palindrome.

        Args:
            n: An int to be checked.

        Returns:
            A bool.

        Used by:
            004, 055 
    """
    word_n = str(n)

    return word_n == word_n[::-1]

def mcm(*xs):
    """ Get the minimal common multiple of numbers xs.

        Args:
            *xs: An assortment of ints.

        Returns:
            An int expressing the mcm of the numbers.

        Used by:
            005
    """
    factors = (get_factors_number(x) for x in xs)
    factors_with_max_exponent = {}

    for counter in factors:
        for prime, times in counter.items():
            saved_factor = factors_with_max_exponent.get(prime)

            if saved_factor is None or saved_factor < times:
                factors_with_max_exponent[prime] = times

    result = 1
    for prime, times in factors_with_max_exponent.items():
        result *= prime**times

    return result

def take(n, iterable):
    """ Yield n items of iterable.

        Args:
            n: an integer
            iterable: an iterator

        Returns:
            A generator of the items.

        Used by:
            033, 044, 046
    """
    return islice(iterable, n)

def find(f, iterable):
    """ Get the first element of the iterable to fulfill the predicate.

        Args:
            f: a function that takes one argument and returns a boolean
            iterable: an iterator

        Returns:
            An iterable element
    """
    for i in iterable:
        if f(i): return i

def generate_primes():
    """ Generate infinite primes.

        Yields:
            Prime ints

        Used by:
            007, 046
    """
    sieve = {}
    yield 2
    
    _from = 2
    limit = 1000002
    step = 1000000

    def do_times(n, iterable):
        counter = 0
        while counter < n:
            counter += 1
            next(iterable, None)

    def prepare_for_sieve(n, sieve):
        current = n**2

        while True:
            sieve[current] = True
            yield
            current += n 
    
    def min_gen():
        for i in range(_from + 1, limit, 2):
            if sieve.get(i):
                continue

            yield i

            sieve_generator = prepare_for_sieve(i, sieve)
            times_to_run = limit // i

            do_times(times_to_run, sieve_generator)
            sieve_generators[i] = sieve_generator

    while True:
        for i in min_gen():
            yield i

        _from = limit
        limit += step 

        for prime, sieving_fun in sieve_generators.items():
            do_times(limit//prime, sieving_fun)

class SieveClass:
    """ A sieve container class that tries to
        emulate Sympy sieve object.

        Used by:
            037
    """
    primes = set()
    biggest_prime = 2
    ordered = list()

    def __init__(self):
        self.prime_gen = self.get_prime_gen()

    def __contains__(self, item):
        while item > self.biggest_prime:
            next(self.prime_gen)

        return item in self.primes

    def __iter__(self):
        return chain(primes, self.prime_gen)

    def ordered_until(self, n):
        if n > self.biggest_prime:
            self._produce_until(n)

        return takewhile(lambda x: x < n, self.ordered)

    def get_prime_gen(self):
        for prime in generate_primes():
            self.biggest_prime = prime
            self.primes.add(prime)
            self.ordered.append(prime)

            yield prime

    def _produce_until(self, value):
        for i in self.prime_gen:
            if value <= i: return

sieve = SieveClass()

def prime_factorization(n):
    for prime in primes_until(int(n**.5) + 1):
        if not n % prime:
            div = n // prime

            return [prime] + prime_factorization(div)

    return [n]

def get_factors_number(n):
    return Counter(prime_factorization(n)) 

def get_factors(n):
    """ Generate the unique prime factors of n

        Yields:
            Prime factors
    """
    sqrt_n = int(n**.5)
    for i in primes_until(sqrt_n):
        if not n % i:
            yield i

def nCk(n, k):
    """ Produce the combinatory result of n choose k.

        Args:
            n, k: ints

        Returns:
            The result as an int.

        Used by:
            053
    """
    return factorial(n)//(factorial(k)*factorial(n-k))

def produce_totients_list(limit):
    """ Generate a list such that index := phi(index).

        Args:
            limit: an int that marks the max number to get the limit of.

        Returns:
            A list with the totients values.

        Used by:
            072
    """
    totients = list(range(0, limit))
    totients[1] = 0

    for prime in primes_until(limit):
        result = 1 - 1/prime
        for i in range(prime, limit, prime):
            totients[i] *= result

    return totients

def get_triangle_perimeters(limit):
    """ Returns how many possible integer rectangle triangles can be generated for 
        every perimeter under limit.

        Args:
            limit: an int that represents the max perimeter.

        Returns:
            An array with index: perimeters and values: how many triplets exists that generate it

        Used by:
            039, 075
    """
    counter = [0] * limit
    
    for m in range(1, floor(limit**.5)):
        sqr_m = m**2
        for n in range(1, m):
            if gcd(m, n) != 1 or (m % 2 and n % 2):
                continue

            perimeter = 2*(sqr_m + m*n) 

            if perimeter > limit:
                break
            else:
                times = limit // perimeter 

                for i in range(1, times+1):
                    counter[perimeter*i] += 1 

    return counter 
